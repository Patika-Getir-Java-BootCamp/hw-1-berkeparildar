1- The non-technical feature of OOP is the fact that it allows us to understand the code we write better by modeling software with real life objects. This approach helps us the developers to plan and structure the project better. From a technical perspective, OOP provides polymorphism and abstraction, which are really important for code reusability and scalability. Polymorphism enavles flexibility and while having multiple instances of a class, and abstraction simplifies complex systems by hiding unnecessary implementation details, which is crucial especially for developers that are joining the project in the midst of it. Some major OOP languages are Java, C#, Swift, that I personally used and followed the OOP approach.

2- An interface is a set of rules, or requiremenets for a class, and that rules or requirements are a set of methods. These methods are provided without the implementation in an interface, which we use to enforce same behaviour between different classes. The biggest difference between interface and abstract classes, and a key use case is that interface supports multiple "inheritance", meaning that a class can implement more than one interface. An abstract class is a stripped down blueprint for classes, allowing both methods with no implementation and with implementation. Abstract classes can also have variables. Interfaces are mostly used to define a set of "behaviours" that mostly unrelated classes use to have these behaviours. While abstract classes are mostly used to define a base class for classes that are related, or similar to each other. 

3- Equals and hashcode methods are important for comparing objects and using them in collections like HashMap and HashSet. The equals method checks if two objects are logically equal based on their content, while hashcode returns a hash code used for efficient storage and retrieval in hash-based collections. We override both methods when we need custom logic for comparing objects or when your class is used in collections that rely on these methods. 

4- This occurs when a class inherits from two classes that both have a common ancestor. This can create confusion when a method is called, as it's unclear which superclass's method should be executed. This problem typically arises in languages that support multiple inheritance, but Java avoids this issue because it does not support multiple inheritance of classes. But, Java allows multiple inheritance of interfaces, and the diamond problem can still happen when a class implements two interfaces that have the same default method.

5- Garbage collector helps us by automating the process of managing memory by removing the unused, none-reference having objects from memory. This is a crucial advantage of Java since automated garbage collection is not available in every language. It typically run when memory is needed, or can be manualy called. 

6- Static keyword is used to define class level members that belong to the class itself instead of any object of that class. It is applied to variables, methods, blocks, and nested classes. Static variables are shared across all instances, and are usually used for constant variables or methods. Static fields have their own address in memory, which makes them shared across all instances.

7- Immutability means that an object’s state cannot be modified after it is created. It is commonly used in records to ensure security, thread safety, and consistency. Immutable objects are useful in multithreaded implementations because they prevent modifications and do not require synchronization of a field. İmmutable classes all fields should be private and final and can not have setter methods.

8- Composition and Aggregation are types of object relationships in OOP that define how objects are related with each other. Composition represents a strong "has-a" relationship, where the child object cannot exist independently of the parent object. If the parent object is destroyed, its dependent objects are also destroyed. Aggregation represents a weak "has-a" relationship, where the generated object can exist independently of the parent. The parent and child have separate lifecycles.

9- Cohesion means how well the elements within a module are related to each other. High cohesion means that a class or module fits well to the "single responsibility" appraoch, making it easier to maintain and reuse. 
Coupling means to measure the degree of dependency between different modules or classes. Low coupling means that modules are independent and are not dependent of each other a lot, making the system more flexible and easier to modify. The difference is that high cohesion improves modularity by keeping related functionality together, while low coupling reduces dependency, allowing changes in one module without heavily impacting others.

10- Heap and stack are two types of memory used for different purposes when the app runs. Heap is used for dynamic memory allocation, where objects and class instances are stored. It is shared across threads and managed by the Garbage Collector. Objects stored in the heap remain in memory until they are no longer referenced. The Stack is used for method execution and local variable storage. Each thread has its own stack, and memory is allocated and deallocated automatically in a LIFO way. The stack is ideal for storing method calls and primitive values, while the heap is good for storing objects and large data structures.

11- Exception is an event that occurs during program execution, usually meaning that something unintended, or unwanted happened during the run of application. Exceptions are important becuase they help us identify the errors easily instead of causing the program to crash. They are categorized into checked exceptions, which the compiler forces to be handled, and unchecked exceptions which can happen because of programming errors and do not require specific handling like NullPointerException.

12- Clean code is code that is understood easily by people working on the project. We talked about the less the code generates comments about it, the cleaner it is. There are patterns that developers follow the create a base for clean code, and these patterns help us follow a structural way of developing that allows our code to be understood better and easily, thus creating "clean code".

13- We use access modifiers, such as private, protected, or default, to control the visibility of methods. For example, marking a method as private makes it so that can only be accessed within the same class and hide it from other classes. Another one is encapsulation, where methods are hidden to protect the internal logic of a class and maintain control over how data is accessed or modifiedd.

14- Abstraction is the concept of hiding the implementation details of a class and exposing only what is necessary to the user. It is done using abstract classes or interfaces. With abstraction, we define what a class should do, instead of saying how it should do it. Polymorphism is the ability of an object to take many forms. It allows a single method to operate on objects of different types, making the code more flexible and reusable. The key difference is that abstraction focuses on hiding the complexity and provides an interface, while polymorphism allows for flexibility in behavior by enabling objects to be treated as instances of their parent class, with their specific behavior determined at runtime.